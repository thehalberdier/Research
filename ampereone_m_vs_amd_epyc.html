<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>AmpereOne M vs AMD EPYC 9554/9654 – Research</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Research</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./rust_primer.html"> 
<span class="menu-text">Rust Primer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./kubernetes_primer.html"> 
<span class="menu-text">Kubernetes Primer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ipsec_primer.html"> 
<span class="menu-text">IPSec Primer</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./hdd_tco_summary.html"> 
<span class="menu-text">HDD TCO</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./ampereone_m_vs_amd_epyc.html" aria-current="page"> 
<span class="menu-text">Ampere vs AMD</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./arista_switch_health_report.html"> 
<span class="menu-text">Arista Health</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sources-used" id="toc-sources-used" class="nav-link active" data-scroll-target="#sources-used">Sources used</a></li>
  <li><a href="#executive-summary-what-changes-vs-your-current-epyc-nodes" id="toc-executive-summary-what-changes-vs-your-current-epyc-nodes" class="nav-link" data-scroll-target="#executive-summary-what-changes-vs-your-current-epyc-nodes">Executive summary (what changes vs your current EPYC nodes)</a></li>
  <li><a href="#at-a-glance-specs-socket-level" id="toc-at-a-glance-specs-socket-level" class="nav-link" data-scroll-target="#at-a-glance-specs-socket-level">At-a-glance specs (socket-level)</a></li>
  <li><a href="#pros-cons-amd-epyc-vs-ampereone-m" id="toc-pros-cons-amd-epyc-vs-ampereone-m" class="nav-link" data-scroll-target="#pros-cons-amd-epyc-vs-ampereone-m">Pros / cons: AMD EPYC vs AmpereOne M</a>
  <ul class="collapse">
  <li><a href="#amd-epyc-95549654-class" id="toc-amd-epyc-95549654-class" class="nav-link" data-scroll-target="#amd-epyc-95549654-class">AMD EPYC (9554/9654 class)</a></li>
  <li><a href="#ampereone-m" id="toc-ampereone-m" class="nav-link" data-scroll-target="#ampereone-m">AmpereOne M</a></li>
  </ul></li>
  <li><a href="#where-to-run-amd-vs-where-to-run-arm-practical-placement-guide" id="toc-where-to-run-amd-vs-where-to-run-arm-practical-placement-guide" class="nav-link" data-scroll-target="#where-to-run-amd-vs-where-to-run-arm-practical-placement-guide">Where to run AMD vs where to run Arm (practical placement guide)</a>
  <ul class="collapse">
  <li><a href="#run-on-amd-epyc-x86_64-when" id="toc-run-on-amd-epyc-x86_64-when" class="nav-link" data-scroll-target="#run-on-amd-epyc-x86_64-when">Run on AMD EPYC (x86_64) when…</a></li>
  <li><a href="#run-on-ampereone-m-arm-when" id="toc-run-on-ampereone-m-arm-when" class="nav-link" data-scroll-target="#run-on-ampereone-m-arm-when">Run on AmpereOne M (Arm) when…</a></li>
  <li><a href="#typical-good-fits-starting-assumptions" id="toc-typical-good-fits-starting-assumptions" class="nav-link" data-scroll-target="#typical-good-fits-starting-assumptions">Typical “good fits” (starting assumptions)</a></li>
  <li><a href="#two-easy-deployment-patterns" id="toc-two-easy-deployment-patterns" class="nav-link" data-scroll-target="#two-easy-deployment-patterns">Two easy deployment patterns</a></li>
  </ul></li>
  <li><a href="#a-simple-decision-tree-for-amd-or-arm" id="toc-a-simple-decision-tree-for-amd-or-arm" class="nav-link" data-scroll-target="#a-simple-decision-tree-for-amd-or-arm">A simple decision tree for “AMD or Arm?”</a></li>
  <li><a href="#architecture-basics-x86_64-amd-epyc-vs-arm64-ampereone-m" id="toc-architecture-basics-x86_64-amd-epyc-vs-arm64-ampereone-m" class="nav-link" data-scroll-target="#architecture-basics-x86_64-amd-epyc-vs-arm64-ampereone-m">Architecture basics: x86_64 (AMD EPYC) vs Arm64 (AmpereOne M)</a>
  <ul class="collapse">
  <li><a href="#instruction-set-isa-and-abi" id="toc-instruction-set-isa-and-abi" class="nav-link" data-scroll-target="#instruction-set-isa-and-abi">1) Instruction set (ISA) and ABI</a></li>
  <li><a href="#simd-vector-extensions-where-hidden-incompatibilities-show-up" id="toc-simd-vector-extensions-where-hidden-incompatibilities-show-up" class="nav-link" data-scroll-target="#simd-vector-extensions-where-hidden-incompatibilities-show-up">2) SIMD / vector extensions (where hidden incompatibilities show up)</a></li>
  <li><a href="#threads-and-scheduling-assumptions" id="toc-threads-and-scheduling-assumptions" class="nav-link" data-scroll-target="#threads-and-scheduling-assumptions">3) Threads and scheduling assumptions</a></li>
  <li><a href="#platform-model-differences" id="toc-platform-model-differences" class="nav-link" data-scroll-target="#platform-model-differences">4) Platform model differences</a></li>
  </ul></li>
  <li><a href="#what-kinds-of-applications-might-not-have-support-on-arm" id="toc-what-kinds-of-applications-might-not-have-support-on-arm" class="nav-link" data-scroll-target="#what-kinds-of-applications-might-not-have-support-on-arm">What kinds of applications might not have support on Arm?</a>
  <ul class="collapse">
  <li><a href="#closed-source-proprietary-binaries" id="toc-closed-source-proprietary-binaries" class="nav-link" data-scroll-target="#closed-source-proprietary-binaries">1) Closed-source / proprietary binaries</a></li>
  <li><a href="#kernel-modules-and-low-level-agents" id="toc-kernel-modules-and-low-level-agents" class="nav-link" data-scroll-target="#kernel-modules-and-low-level-agents">2) Kernel modules and low-level agents</a></li>
  <li><a href="#language-ecosystems-with-native-extensions-it-installs-until-it-doesnt" id="toc-language-ecosystems-with-native-extensions-it-installs-until-it-doesnt" class="nav-link" data-scroll-target="#language-ecosystems-with-native-extensions-it-installs-until-it-doesnt">3) Language ecosystems with native extensions (it “installs” until it doesn’t)</a></li>
  <li><a href="#applications-depending-on-x86-specific-optimizations" id="toc-applications-depending-on-x86-specific-optimizations" class="nav-link" data-scroll-target="#applications-depending-on-x86-specific-optimizations">4) Applications depending on x86-specific optimizations</a></li>
  <li><a href="#virtualization-and-guest-os-constraints" id="toc-virtualization-and-guest-os-constraints" class="nav-link" data-scroll-target="#virtualization-and-guest-os-constraints">5) Virtualization and guest OS constraints</a></li>
  </ul></li>
  <li><a href="#fast-ways-to-detect-arm-readiness-before-you-buy-a-lot-of-servers" id="toc-fast-ways-to-detect-arm-readiness-before-you-buy-a-lot-of-servers" class="nav-link" data-scroll-target="#fast-ways-to-detect-arm-readiness-before-you-buy-a-lot-of-servers">Fast ways to detect Arm readiness (before you buy a lot of servers)</a></li>
  <li><a href="#equivalent-cpu-selection-how-to-map-epyc-95549654-ampereone-m" id="toc-equivalent-cpu-selection-how-to-map-epyc-95549654-ampereone-m" class="nav-link" data-scroll-target="#equivalent-cpu-selection-how-to-map-epyc-95549654-ampereone-m">“Equivalent” CPU selection: how to map EPYC 9554/9654 → AmpereOne M</a>
  <ul class="collapse">
  <li><a href="#practical-mapping-shortlist-starting-point" id="toc-practical-mapping-shortlist-starting-point" class="nav-link" data-scroll-target="#practical-mapping-shortlist-starting-point">Practical mapping shortlist (starting point)</a></li>
  <li><a href="#one-hard-constraint-pcie-lane-budget" id="toc-one-hard-constraint-pcie-lane-budget" class="nav-link" data-scroll-target="#one-hard-constraint-pcie-lane-budget">One hard constraint: PCIe lane budget</a></li>
  </ul></li>
  <li><a href="#gigabyte-r1a3-t40-aav1-notes-ampereone-m-platform" id="toc-gigabyte-r1a3-t40-aav1-notes-ampereone-m-platform" class="nav-link" data-scroll-target="#gigabyte-r1a3-t40-aav1-notes-ampereone-m-platform">GIGABYTE R1A3-T40-AAV1 notes (AmpereOne M platform)</a></li>
  <li><a href="#recommendation-a-minimal-decision-oriented-poc" id="toc-recommendation-a-minimal-decision-oriented-poc" class="nav-link" data-scroll-target="#recommendation-a-minimal-decision-oriented-poc">Recommendation: a minimal, decision-oriented POC</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AmpereOne M vs AMD EPYC 9554/9654</h1>
<p class="subtitle lead">Pros/cons, platform trade-offs, and how to pick “equivalent” SKUs</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sources-used" class="level2">
<h2 class="anchored" data-anchor-id="sources-used">Sources used</h2>
<ul>
<li>AmpereOne M product brief: <a href="https://amperecomputing.com/briefs/ampereone-m-product-brief" class="uri">https://amperecomputing.com/briefs/ampereone-m-product-brief</a></li>
<li>GIGABYTE R1A3-T40-AAV1 (your link may geo-block; this mirror usually works): <a href="https://www.gigabyte.com/il/Enterprise/Rack-Server/R1A3-T40-AAV1" class="uri">https://www.gigabyte.com/il/Enterprise/Rack-Server/R1A3-T40-AAV1</a></li>
<li>AMD EPYC 9004 series datasheet (model table includes 9554/9654): <a href="https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/datasheets/amd-epyc-9004-series-processors-datasheet.pdf" class="uri">https://www.amd.com/content/dam/amd/en/documents/epyc-business-docs/datasheets/amd-epyc-9004-series-processors-datasheet.pdf</a></li>
</ul>
</section>
<section id="executive-summary-what-changes-vs-your-current-epyc-nodes" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary-what-changes-vs-your-current-epyc-nodes">Executive summary (what changes vs your current EPYC nodes)</h2>
<p>You’re comparing two <strong>very different</strong> approaches to “core dense”:</p>
<ul>
<li><strong>AMD EPYC 9554 / 9654 (x86_64 + SMT)</strong>: fewer cores than Ampere’s top-end SKUs, but <strong>2 threads/core</strong>, strong per-core performance, and <strong>more I/O (128 PCIe Gen5 lanes)</strong>.</li>
<li><strong>AmpereOne M (Armv8.6+, single-threaded cores)</strong>: many single-threaded cores with <strong>12-channel DDR5-5600</strong>, and a platform story optimized for <em>predictable, scale-out throughput</em> — but <strong>fewer I/O lanes (96 PCIe Gen5)</strong> and an <strong>Arm software/ops compatibility tax</strong> if your stack isn’t already Arm-friendly.</li>
</ul>
</section>
<section id="at-a-glance-specs-socket-level" class="level2">
<h2 class="anchored" data-anchor-id="at-a-glance-specs-socket-level">At-a-glance specs (socket-level)</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 26%">
<col style="width: 26%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th>Item</th>
<th style="text-align: right;">AMD EPYC 9554</th>
<th style="text-align: right;">AMD EPYC 9654</th>
<th style="text-align: right;">AmpereOne M (family)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ISA / platform</td>
<td style="text-align: right;">x86_64 (SP5)</td>
<td style="text-align: right;">x86_64 (SP5)</td>
<td style="text-align: right;">Armv8.6+ (SoC)</td>
</tr>
<tr class="even">
<td>Cores / threads</td>
<td style="text-align: right;">64 / 128</td>
<td style="text-align: right;">96 / 192</td>
<td style="text-align: right;">96–192 / 96–192 (single-thread)</td>
</tr>
<tr class="odd">
<td>Base / boost (GHz)</td>
<td style="text-align: right;">3.10 / 3.75</td>
<td style="text-align: right;">2.40 / 3.70</td>
<td style="text-align: right;">Model-dependent (2.6–3.6 shown)</td>
</tr>
<tr class="even">
<td>Default / usage power</td>
<td style="text-align: right;">360W (default TDP)</td>
<td style="text-align: right;">360W (default TDP)</td>
<td style="text-align: right;">239–348W “Usage Power*” by model (brief)</td>
</tr>
<tr class="odd">
<td>Memory channels</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">12</td>
<td style="text-align: right;">12</td>
</tr>
<tr class="even">
<td>Max DDR5 speed (1DPC)</td>
<td style="text-align: right;">4800 MT/s</td>
<td style="text-align: right;">4800 MT/s</td>
<td style="text-align: right;">5600 MT/s (brief)</td>
</tr>
<tr class="odd">
<td>Peak memory bandwidth</td>
<td style="text-align: right;">460.8 GB/s (datasheet)</td>
<td style="text-align: right;">460.8 GB/s (datasheet)</td>
<td style="text-align: right;">~537.6 GB/s (12 × 5600 MT/s × 8 B; theoretical)</td>
</tr>
<tr class="even">
<td>PCIe Gen5 lanes</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">128</td>
<td style="text-align: right;">96 (brief)</td>
</tr>
</tbody>
</table>
</section>
<section id="pros-cons-amd-epyc-vs-ampereone-m" class="level2">
<h2 class="anchored" data-anchor-id="pros-cons-amd-epyc-vs-ampereone-m">Pros / cons: AMD EPYC vs AmpereOne M</h2>
<section id="amd-epyc-95549654-class" class="level3">
<h3 class="anchored" data-anchor-id="amd-epyc-95549654-class">AMD EPYC (9554/9654 class)</h3>
<p><strong>Pros</strong></p>
<ul>
<li><strong>Software compatibility</strong>: x86_64 “just works” for the broadest set of enterprise software, drivers, agents, and proprietary stacks.</li>
<li><strong>High thread count with SMT</strong>: if your workload benefits from SMT, you get <strong>2× threads/core</strong>.</li>
<li><strong>I/O headroom</strong>: <strong>128 lanes of PCIe Gen5</strong> per socket is hard to beat when you need many GPUs / NICs / NVMe.</li>
<li><strong>Mature tuning + observability</strong>: generally easier to find established guidance for BIOS, NUMA, perf counters, and vendor ecosystem tooling.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li><strong>Higher platform power for a given <em>throughput-per-rack</em> goal</strong> if you’re ultimately limited by memory bandwidth efficiency or “scale-out core density”.</li>
<li><strong>License cost sensitivity</strong> for software priced per core / per socket can dominate your economics (depends on your stack).</li>
</ul>
</section>
<section id="ampereone-m" class="level3">
<h3 class="anchored" data-anchor-id="ampereone-m">AmpereOne M</h3>
<p><strong>Pros</strong></p>
<ul>
<li><strong>Core density</strong>: 96–192 single-threaded cores per socket can increase <em>throughput-per-rack</em> for workloads that scale well with more independent threads (stateless services, batchy inference, analytics pipelines).</li>
<li><strong>Memory bandwidth focus</strong>: <strong>12-channel DDR5-5600</strong> (brief) is a clear design point for bandwidth-sensitive throughput workloads.</li>
<li><strong>Predictability</strong>: single-threaded cores and the “cloud native” design goal can help with performance consistency (still validate on your stack).</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li><strong>Arm migration/ops tax</strong>: base images, agents, proprietary libs, and vendor support may lag x86_64 depending on your environment.</li>
<li><strong>Vector ISA / codegen differences</strong>: CPU instruction set and library ecosystem differ; some workloads need re-tuning or don’t have comparable optimized kernels.</li>
<li><strong>Less PCIe lane budget</strong>: <strong>96 PCIe Gen5 lanes</strong> (brief) can be a real constraint for GPU/NVMe/NIC-heavy designs.</li>
</ul>
</section>
</section>
<section id="where-to-run-amd-vs-where-to-run-arm-practical-placement-guide" class="level2">
<h2 class="anchored" data-anchor-id="where-to-run-amd-vs-where-to-run-arm-practical-placement-guide">Where to run AMD vs where to run Arm (practical placement guide)</h2>
<p>Think of <strong>Arm (AmpereOne M)</strong> as a <em>throughput-per-watt / scale-out</em> play, and <strong>AMD EPYC</strong> as the <em>lowest-risk default</em> for compatibility + per-thread performance + I/O-heavy nodes.</p>
<section id="run-on-amd-epyc-x86_64-when" class="level3">
<h3 class="anchored" data-anchor-id="run-on-amd-epyc-x86_64-when">Run on AMD EPYC (x86_64) when…</h3>
<ul>
<li><strong>You can’t fully support Arm in prod yet</strong>: any “must have” component is x86-only (vendor app, security agent, backup agent, monitoring, kernel module, proprietary driver, etc.).</li>
<li><strong>Single-thread and tail latency dominate</strong>: workloads with strict p95/p99 latency, high per-request CPU, or limited parallelism tend to prefer strong per-core performance.</li>
<li><strong>Your nodes are I/O-lane constrained</strong>: you need lots of PCIe devices per socket (GPUs, multiple high-speed NICs, many NVMe drives, HBAs/DPUs). EPYC’s <strong>128 PCIe Gen5 lanes</strong> is a big advantage.</li>
<li><strong>You rely on x86-specific acceleration or tuning</strong>: compiled kernels, hand-tuned libraries, or toolchains that assume x86 (common in HPC/EDA/legacy stacks).</li>
<li><strong>Software licensing penalizes high core counts</strong>: if your critical software is licensed per core, a 160–192-core Arm CPU can be economically worse even if it’s efficient.</li>
</ul>
</section>
<section id="run-on-ampereone-m-arm-when" class="level3">
<h3 class="anchored" data-anchor-id="run-on-ampereone-m-arm-when">Run on AmpereOne M (Arm) when…</h3>
<ul>
<li><strong>Your stack is “rebuildable”</strong>: you can build and ship <code>linux/arm64</code> artifacts (or use multi-arch container images) for the app <em>and</em> its dependencies.</li>
<li><strong>Throughput scales with more independent threads</strong>: stateless services, web/API tiers, batch workers, message consumers, ETL steps, and many “embarrassingly parallel” jobs.</li>
<li><strong>You’re memory bandwidth sensitive</strong>: AmpereOne M is explicitly positioned around <strong>12-channel DDR5-5600</strong> and core density; that’s often a good fit when you’re bottlenecked on memory throughput rather than per-thread IPC.</li>
<li><strong>Power/rack density is a primary constraint</strong>: if you’re hitting rack power limits before space limits, Arm’s efficiency goals can translate into real capacity gains (validate with your workload).</li>
</ul>
</section>
<section id="typical-good-fits-starting-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="typical-good-fits-starting-assumptions">Typical “good fits” (starting assumptions)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Workload area</th>
<th>Default pick</th>
<th>When Arm usually makes sense</th>
<th>When AMD usually stays better</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Web / API stateless services</td>
<td>Arm candidate</td>
<td>Go/Java/Node services, containerized, easy CI builds, horizontal scaling</td>
<td>Very latency-sensitive endpoints or hard-to-rebuild legacy deps</td>
</tr>
<tr class="even">
<td>Batch workers / queues</td>
<td>Arm candidate</td>
<td>High parallelism, lots of concurrent jobs, predictable CPU work</td>
<td>Jobs with specialized x86-only libraries or heavy per-thread performance needs</td>
</tr>
<tr class="odd">
<td>Databases / stateful data</td>
<td>AMD default</td>
<td>Open-source DBs you can validate thoroughly; read-heavy fleets; cost/power pressure</td>
<td>Vendor appliances, x86-tuned deployments, extreme p99 requirements, or “one big box” scaling</td>
</tr>
<tr class="even">
<td>CPU-only inference</td>
<td>depends</td>
<td>Many concurrent small models / pipelines, throughput-oriented serving</td>
<td>If per-request latency is strict and model kernels are x86-optimized in your stack</td>
</tr>
<tr class="odd">
<td>GPU-heavy training/inference</td>
<td>AMD default (for CPU host)</td>
<td>Only if the exact GPU + driver + orchestration stack is proven on Arm</td>
<td>When you need maximum PCIe lanes and broadest ecosystem support</td>
</tr>
<tr class="even">
<td>Virtualization platforms</td>
<td>AMD default</td>
<td>If you run KVM and have full tool/agent support on Arm</td>
<td>If you rely on VMware or x86-only guest/management tooling</td>
</tr>
</tbody>
</table>
</section>
<section id="two-easy-deployment-patterns" class="level3">
<h3 class="anchored" data-anchor-id="two-easy-deployment-patterns">Two easy deployment patterns</h3>
<ol type="1">
<li><strong>Separate node pools / fleets</strong>:
<ul>
<li><code>amd64</code> pool for “everything works” workloads.</li>
<li><code>arm64</code> pool for explicitly qualified workloads.</li>
</ul></li>
<li><strong>Kubernetes: schedule by architecture</strong>:
<ul>
<li>Build multi-arch images and use node selectors/affinity (e.g., <code>kubernetes.io/arch=arm64</code>).</li>
</ul></li>
</ol>
</section>
</section>
<section id="a-simple-decision-tree-for-amd-or-arm" class="level2">
<h2 class="anchored" data-anchor-id="a-simple-decision-tree-for-amd-or-arm">A simple decision tree for “AMD or Arm?”</h2>
<ol type="1">
<li><strong>Can I run it on Arm without heroics?</strong> (build + deps + agents + drivers)
<ul>
<li>No → <strong>AMD</strong></li>
</ul></li>
<li><strong>Is it I/O-lane heavy?</strong> (lots of PCIe devices per node)
<ul>
<li>Yes → <strong>AMD</strong></li>
</ul></li>
<li><strong>Is single-thread / p99 critical and hard to parallelize?</strong>
<ul>
<li>Yes → <strong>AMD</strong></li>
</ul></li>
<li><strong>Otherwise, does it scale with many independent threads and is power/cost a concern?</strong>
<ul>
<li>Yes → <strong>Arm candidate</strong>, then validate perf/W and perf/$ in a POC</li>
</ul></li>
</ol>
</section>
<section id="architecture-basics-x86_64-amd-epyc-vs-arm64-ampereone-m" class="level2">
<h2 class="anchored" data-anchor-id="architecture-basics-x86_64-amd-epyc-vs-arm64-ampereone-m">Architecture basics: x86_64 (AMD EPYC) vs Arm64 (AmpereOne M)</h2>
<p>At a high level, both are modern 64-bit server CPUs running Linux, but they differ in the <strong>instruction set</strong>, <strong>ecosystem assumptions</strong>, and some <strong>performance/optimization “defaults”</strong>.</p>
<section id="instruction-set-isa-and-abi" class="level3">
<h3 class="anchored" data-anchor-id="instruction-set-isa-and-abi">1) Instruction set (ISA) and ABI</h3>
<ul>
<li><strong>AMD EPYC</strong> runs <strong>x86_64</strong> binaries (ELF <code>x86-64</code>).</li>
<li><strong>AmpereOne M</strong> runs <strong>AArch64 / arm64</strong> binaries (ELF <code>aarch64</code>).</li>
</ul>
<p>This is the root cause of most “doesn’t run on Arm” issues: a prebuilt program compiled for x86_64 cannot execute on Arm64 without recompilation (or emulation, which is usually not acceptable for production performance).</p>
</section>
<section id="simd-vector-extensions-where-hidden-incompatibilities-show-up" class="level3">
<h3 class="anchored" data-anchor-id="simd-vector-extensions-where-hidden-incompatibilities-show-up">2) SIMD / vector extensions (where hidden incompatibilities show up)</h3>
<p>Many “CPU-intensive” libraries rely on vector instruction sets.</p>
<ul>
<li>x86 often leans on <strong>SSE/AVX/AVX2/AVX-512</strong>.</li>
<li>Arm commonly uses <strong>NEON</strong> (and sometimes <strong>SVE/SVE2</strong> depending on CPU and build targets).</li>
</ul>
<p>If an application (or a dependency) ships <strong>x86-only optimized code paths</strong> (e.g., AVX-512) and doesn’t provide Arm equivalents, you can see: - “Illegal instruction” crashes (if runtime dispatch is wrong), - or it compiles/runs but performs much worse (falls back to scalar code).</p>
</section>
<section id="threads-and-scheduling-assumptions" class="level3">
<h3 class="anchored" data-anchor-id="threads-and-scheduling-assumptions">3) Threads and scheduling assumptions</h3>
<ul>
<li>Your EPYC nodes use <strong>SMT</strong> (2 threads/core), so software often sees “more CPUs” than physical cores.</li>
<li>AmpereOne M cores are positioned as <strong>single-threaded cores</strong> (1 thread/core).</li>
</ul>
<p>Applications that were tuned assuming SMT behavior (thread pool sizing, CPU pinning, latency isolation) may need re-tuning on Arm even if they are “supported”.</p>
</section>
<section id="platform-model-differences" class="level3">
<h3 class="anchored" data-anchor-id="platform-model-differences">4) Platform model differences</h3>
<ul>
<li>EPYC is a classic server CPU platform (CPU + chipset/IOD, SP5 ecosystem).</li>
<li>AmpereOne M is more <strong>SoC-like</strong> in how the platform is built and validated (still standard server components, but a different vendor ecosystem).</li>
</ul>
<p>Practically, this affects <strong>out-of-tree drivers</strong>, BIOS/firmware tooling, and vendor-provided management integrations.</p>
</section>
</section>
<section id="what-kinds-of-applications-might-not-have-support-on-arm" class="level2">
<h2 class="anchored" data-anchor-id="what-kinds-of-applications-might-not-have-support-on-arm">What kinds of applications might not have support on Arm?</h2>
<p>The pattern is: <strong>anything delivered only as an x86_64 binary</strong> (or relying on x86-only kernel/user-space components).</p>
<section id="closed-source-proprietary-binaries" class="level3">
<h3 class="anchored" data-anchor-id="closed-source-proprietary-binaries">1) Closed-source / proprietary binaries</h3>
<ul>
<li>Commercial software distributed as a single x86_64 build (no Arm download).</li>
<li>“Appliance-like” stacks where the vendor only certifies x86_64.</li>
<li>Legacy enterprise software that embeds x86 native components.</li>
</ul>
</section>
<section id="kernel-modules-and-low-level-agents" class="level3">
<h3 class="anchored" data-anchor-id="kernel-modules-and-low-level-agents">2) Kernel modules and low-level agents</h3>
<p>These are common early blockers: - Endpoint/security agents (EDR), DLP, vulnerability scanners - Backup agents - Storage/network drivers, RDMA stacks, DPDK variants (depends), special NIC features - GPU/accelerator drivers and management tooling (often works on Arm in some combos, but don’t assume)</p>
<p>If the solution requires a <strong>kernel module</strong>, you need explicit Arm64 support for your kernel + distro combination.</p>
</section>
<section id="language-ecosystems-with-native-extensions-it-installs-until-it-doesnt" class="level3">
<h3 class="anchored" data-anchor-id="language-ecosystems-with-native-extensions-it-installs-until-it-doesnt">3) Language ecosystems with native extensions (it “installs” until it doesn’t)</h3>
<p>Even when your application is “portable” (Go/Java/Python/Node), its dependencies may include native code:</p>
<ul>
<li><strong>Python</strong>: <code>pip</code> packages with native wheels may be missing <code>manylinux_aarch64</code> wheels, forcing source builds (which may fail due to missing toolchains or incompatible C/ASM).</li>
<li><strong>Node.js</strong>: native addons (<code>node-gyp</code>) may lack arm64 prebuilds.</li>
<li><strong>Java/JVM</strong>: the JVM itself supports arm64 well, but JNI libraries might not.</li>
<li><strong>Rust/C/C++</strong>: usually fine if you build from source, but some projects have x86-only assembly.</li>
</ul>
</section>
<section id="applications-depending-on-x86-specific-optimizations" class="level3">
<h3 class="anchored" data-anchor-id="applications-depending-on-x86-specific-optimizations">4) Applications depending on x86-specific optimizations</h3>
<p>Examples: - Media/codec stacks tuned for x86 intrinsics only - Some HPC/EDA toolchains and proprietary numeric libraries - Any codebase with hand-written x86 assembly</p>
</section>
<section id="virtualization-and-guest-os-constraints" class="level3">
<h3 class="anchored" data-anchor-id="virtualization-and-guest-os-constraints">5) Virtualization and guest OS constraints</h3>
<ul>
<li>If you need to run <strong>x86_64 guests</strong> on the same host, Arm servers can’t do that natively.</li>
<li>Some virtualization ecosystems (notably VMware) are effectively x86-only in common enterprise deployments.</li>
</ul>
</section>
</section>
<section id="fast-ways-to-detect-arm-readiness-before-you-buy-a-lot-of-servers" class="level2">
<h2 class="anchored" data-anchor-id="fast-ways-to-detect-arm-readiness-before-you-buy-a-lot-of-servers">Fast ways to detect Arm readiness (before you buy a lot of servers)</h2>
<ul>
<li><strong>Container images</strong>: do they publish <code>linux/arm64</code>?
<ul>
<li><code>docker manifest inspect &lt;image&gt;:&lt;tag&gt; | rg -n \"arm64|amd64\"</code></li>
</ul></li>
<li><strong>Linux packages</strong>: do they ship <code>aarch64/arm64</code> builds for your distro?
<ul>
<li>Debian/Ubuntu: check <code>arm64</code> availability in your repo + vendor repo.</li>
<li>RHEL-like: check <code>aarch64</code> RPM availability and kernel module support.</li>
</ul></li>
<li><strong>Your own binaries</strong>: can you build and run CI for arm64?
<ul>
<li><code>uname -m</code> on the target (<code>aarch64</code> vs <code>x86_64</code>)</li>
<li><code>file &lt;binary&gt;</code> should show <code>aarch64</code> for Arm targets.</li>
</ul></li>
</ul>
</section>
<section id="equivalent-cpu-selection-how-to-map-epyc-95549654-ampereone-m" class="level2">
<h2 class="anchored" data-anchor-id="equivalent-cpu-selection-how-to-map-epyc-95549654-ampereone-m">“Equivalent” CPU selection: how to map EPYC 9554/9654 → AmpereOne M</h2>
<p>There isn’t a single “equivalent”, because <em>AMD cores and Ampere cores are not interchangeable</em>. Pick equivalence based on what you’re trying to preserve:</p>
<ol type="1">
<li><strong>Thread budget equivalence</strong> (how many runnable software threads you want per node)</li>
<li><strong>Power envelope equivalence</strong> (stay within a rack/power budget per node)</li>
<li><strong>Memory bandwidth equivalence</strong> (channels × speed, plus workload memory behavior)</li>
<li><strong>I/O equivalence</strong> (PCIe lanes and slot topology)</li>
<li><strong>Single-thread / tail-latency equivalence</strong> (p99 requirements)</li>
</ol>
<section id="practical-mapping-shortlist-starting-point" class="level3">
<h3 class="anchored" data-anchor-id="practical-mapping-shortlist-starting-point">Practical mapping shortlist (starting point)</h3>
<p>Use this as a <strong>POC shortlist</strong>, not a final answer.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>If you run today…</th>
<th>What you likely value</th>
<th>AmpereOne M candidates to try</th>
<th>Why these are “closest”</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>EPYC 9554 (64C/128T, 360W)</strong></td>
<td>higher per-core perf, moderate core count, still lots of threads</td>
<td><strong>A96-36M (96C @ 3.6, 331W)</strong>, <strong>A144-33M (144C @ 3.3, 334W)</strong>, <strong>A144-26M (144C @ 2.6, 239W)</strong></td>
<td>A96-36M is the “fewer cores, higher freq” end; A144 variants test whether more cores improves throughput under similar or lower power</td>
</tr>
<tr class="even">
<td><strong>EPYC 9654 (96C/192T, 360W)</strong></td>
<td>high thread count / throughput per node</td>
<td><strong>A192-32M (192C @ 3.2, 348W)</strong>, <strong>A160-28M (160C @ 2.8, 262W)</strong>, <strong>A192-26M (192C @ 2.6, 278W)</strong></td>
<td>A192-32M matches the <em>thread budget</em> (192) at similar power; A160/A192-26M are “efficiency-first” comparators</td>
</tr>
</tbody>
</table>
</section>
<section id="one-hard-constraint-pcie-lane-budget" class="level3">
<h3 class="anchored" data-anchor-id="one-hard-constraint-pcie-lane-budget">One hard constraint: PCIe lane budget</h3>
<p>If your current EPYC nodes are built around <strong>lane-heavy designs</strong> (many NVMe drives, multiple NICs, GPUs, DPUs), treat <strong>128 lanes (EPYC) vs 96 lanes (AmpereOne M)</strong> as a first-order design constraint. It can change the entire server bill of materials more than the CPU choice itself.</p>
</section>
</section>
<section id="gigabyte-r1a3-t40-aav1-notes-ampereone-m-platform" class="level2">
<h2 class="anchored" data-anchor-id="gigabyte-r1a3-t40-aav1-notes-ampereone-m-platform">GIGABYTE R1A3-T40-AAV1 notes (AmpereOne M platform)</h2>
<p>From the vendor spec page, this platform is a <strong>1U, single-socket</strong> AmpereOne M server with:</p>
<ul>
<li>12 DDR5 RDIMM slots (12-channel per CPU)</li>
<li>4 front hot-swap bays (Gen5 NVMe / SATA / SAS-4 support)</li>
<li>2 × FHHL PCIe Gen5 x16 slots + 2 × OCP NIC 3.0 PCIe Gen5 x16 slots</li>
<li>Redundant power supplies (config shown as Titanium-class)</li>
</ul>
<p>This makes it a reasonable evaluation chassis for <strong>NIC + accelerator + limited local storage</strong> designs; less ideal if you need lots of front NVMe bays in 1U.</p>
</section>
<section id="recommendation-a-minimal-decision-oriented-poc" class="level2">
<h2 class="anchored" data-anchor-id="recommendation-a-minimal-decision-oriented-poc">Recommendation: a minimal, decision-oriented POC</h2>
<ol type="1">
<li><strong>Pick one workload per “shape”</strong> you run: (a) latency-sensitive service, (b) batch/throughput service, (c) memory-bandwidth-heavy job, (d) IO-heavy node.</li>
<li><strong>Test 2 Ampere SKUs per AMD SKU</strong> (from the shortlist) and keep memory config constant (same capacity per channel).</li>
<li><strong>Compare</strong>: throughput/socket, p99 latency, perf/W, and perf/$ (including any software/license deltas).</li>
<li><strong>Fail fast on compatibility</strong>: image build, agents, monitoring, kernel/driver support, and any proprietary binaries.</li>
</ol>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/thehalberdier\.github\.io\/Research\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>