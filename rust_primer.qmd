---
title: "Rust Primer for C++/Java Developers"
author: "Research Notes"
date: "2026-02-10"
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
---

> **Goal**: Get you to ~80% of Rust, fast. Assumes you know C++/Java, understand types, pointers, and memory.
> Skips: async runtime internals, FFI, advanced lifetime gymnastics.

---

## 1. First Things First: Cargo & Project Setup

Cargo is Rust's build system + package manager. Think CMake + Conan + Maven rolled into one, but actually pleasant.

```bash
cargo new myproject        # creates a new binary project
cargo new mylib --lib      # creates a library
cargo build                # compile (debug)
cargo build --release      # compile (optimized)
cargo run                  # build + run
cargo test                 # run tests
cargo add serde            # add a dependency (like `npm install`)
```

Project structure:
```
myproject/
â”œâ”€â”€ Cargo.toml             # like pom.xml / CMakeLists.txt
â”œâ”€â”€ src/
â”‚   â””â”€â”€ main.rs            # entry point (fn main)
```

`Cargo.toml` declares dependencies:
```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
```

Crates.io is the package registry (like Maven Central / crates â‰ˆ packages).

---

## 2. The Big Idea: Ownership

This is THE thing that makes Rust different. If you internalize this section, the rest falls into place.

### The Three Rules

1. Every value has exactly **one owner** (a variable).
2. When the owner goes out of scope, the value is **dropped** (destructor runs, memory freed).
3. Ownership can be **moved**, but then the old variable is invalid.

```rust
fn main() {
    let s1 = String::from("hello");  // s1 owns the String
    let s2 = s1;                      // ownership MOVED to s2
    // println!("{}", s1);            // COMPILE ERROR: s1 is no longer valid
    println!("{}", s2);               // fine
}
```

**C++ analogy**: Think `std::unique_ptr`. Assignment = move. But Rust enforces this for ALL types at compile time, not just smart pointers.

**Java comparison**: In Java, `s2 = s1` makes both point to the same object. In Rust, `s1` is dead after the move.

### Stack vs. Heap & Copy Types

Simple scalar types (`i32`, `f64`, `bool`, `char`, tuples of these) implement `Copy` â€” they're copied on assignment, not moved. Just like in C++.

```rust
let x = 5;
let y = x;       // x is copied, both valid
println!("{x} {y}"); // fine
```

Heap-allocated types (`String`, `Vec<T>`, `Box<T>`) are moved.

### Clone: Explicit Deep Copy

If you actually want a deep copy, say so:

```rust
let s1 = String::from("hello");
let s2 = s1.clone();  // explicit deep copy
println!("{s1} {s2}"); // both valid
```

---

## 3. Borrowing & References

You don't always want to move ownership. Borrowing lets you lend access.

```rust
fn print_length(s: &String) {   // borrows s (immutable reference)
    println!("len = {}", s.len());
}

fn main() {
    let s = String::from("hello");
    print_length(&s);            // lend s
    println!("{s}");             // still valid â€” we only lent it
}
```

### The Borrowing Rules

At any given time, you can have **either**:
- **Any number** of immutable references (`&T`), **OR**
- **Exactly one** mutable reference (`&mut T`)

Never both at the same time.

```rust
let mut s = String::from("hello");

let r1 = &s;       // ok
let r2 = &s;       // ok â€” multiple immutable refs fine
// let r3 = &mut s; // COMPILE ERROR: can't borrow mutably while immutable refs exist

println!("{r1} {r2}");
// r1, r2 no longer used after this point (their lifetime ends)

let r3 = &mut s;   // now ok â€” no immutable refs alive
r3.push_str(" world");
```

**Why**: This is Rust's compile-time data race prevention. No reader-writer conflicts, ever.

**C++ analogy**: Like `const T&` vs `T&`, but the compiler actually enforces that you can't alias a mutable ref.

---

## 4. Lifetimes (The Minimum You Need)

Lifetimes ensure references don't outlive the data they point to. Most of the time, the compiler infers them. You only write them when the compiler can't figure it out â€” typically in function signatures returning references.

```rust
// "The returned reference lives as long as BOTH inputs live"
fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() >= s2.len() { s1 } else { s2 }
}
```

`'a` is a lifetime parameter. Read it as: "the output reference is valid for at least as long as both input references."

**Practical rule of thumb**: If the compiler says "missing lifetime specifier," add `<'a>` to the function and annotate the references. If you're storing references in a struct, you need lifetimes on the struct too:

```rust
struct Excerpt<'a> {
    text: &'a str,   // this struct can't outlive the string it borrows
}
```

**Escape hatch**: If lifetimes get painful, just own the data instead (`String` instead of `&str`, `Vec<T>` instead of `&[T]`). Cloning is fine. Don't fight the borrow checker when you're learning.

---

## 5. Types, Structs, Enums

### Primitive Types

```rust
let x: i32 = 42;        // signed: i8, i16, i32, i64, i128, isize
let y: u64 = 100;       // unsigned: u8, u16, u32, u64, u128, usize
let f: f64 = 3.14;      // f32, f64
let b: bool = true;
let c: char = 'ðŸ¦€';     // 4 bytes, Unicode scalar value
```

`usize` / `isize` = pointer-sized integers. Used for indexing.

### Structs (like C++ structs / Java classes, but no inheritance)

```rust
struct Server {
    hostname: String,
    cpu_cores: u32,
    is_active: bool,
}

impl Server {
    // Associated function (like static method). Convention: `new` is the constructor.
    fn new(hostname: String, cores: u32) -> Self {
        Server {
            hostname,          // shorthand when field name == variable name
            cpu_cores: cores,
            is_active: true,
        }
    }

    // Method: takes &self (immutable borrow of the instance)
    fn summary(&self) -> String {
        format!("{}: {} cores", self.hostname, self.cpu_cores)
    }

    // Mutable method: takes &mut self
    fn deactivate(&mut self) {
        self.is_active = false;
    }
}

fn main() {
    let mut srv = Server::new("node-01".to_string(), 64);
    println!("{}", srv.summary());
    srv.deactivate();
}
```

**No inheritance.** Composition + traits instead (see Â§7).

### Enums (WAY more powerful than C++/Java enums)

Rust enums are algebraic data types (tagged unions). Each variant can hold data.

```rust
enum StorageBackend {
    Local { path: String },
    Ceph { pool: String, namespace: String },
    NVMe { device_id: u32 },
    None,
}

fn describe(backend: &StorageBackend) {
    match backend {
        StorageBackend::Local { path } => println!("Local at {path}"),
        StorageBackend::Ceph { pool, .. } => println!("Ceph pool: {pool}"),
        StorageBackend::NVMe { device_id } => println!("NVMe dev {device_id}"),
        StorageBackend::None => println!("No storage"),
    }
}
```

**C++ analogy**: `std::variant`, but with exhaustive pattern matching enforced by the compiler.

---

## 6. Pattern Matching

`match` is like `switch` on steroids. It's exhaustive â€” you must handle every case.

```rust
let x = 42;

match x {
    0 => println!("zero"),
    1..=10 => println!("small"),
    11 | 12 => println!("eleven or twelve"),
    n if n < 0 => println!("negative: {n}"),   // guard
    _ => println!("something else"),             // _ = default
}
```

### `if let` â€” when you only care about one variant

```rust
let maybe_name: Option<String> = Some("venkat".to_string());

if let Some(name) = maybe_name {
    println!("Got: {name}");
}
// Use this instead of a full match when you don't care about the other cases.
```

### `let ... else` â€” early return on mismatch (Rust 1.65+)

```rust
fn process(val: Option<i32>) {
    let Some(x) = val else {
        println!("was None, bailing");
        return;
    };
    println!("processing {x}");
}
```

---

## 7. Traits (â‰ˆ Interfaces + Typeclasses)

Traits define shared behavior. Like Java interfaces, but can have default implementations and can be implemented for types you didn't define.

```rust
trait Describable {
    fn describe(&self) -> String;

    // Default implementation (like Java default methods)
    fn short_desc(&self) -> String {
        format!("{}...", &self.describe()[..20.min(self.describe().len())])
    }
}

impl Describable for Server {
    fn describe(&self) -> String {
        format!("Server {} with {} cores", self.hostname, self.cpu_cores)
    }
}
```

### Trait Bounds (= Generics constrained by traits)

```rust
// Any T that implements Describable
fn log_item<T: Describable>(item: &T) {
    println!("[LOG] {}", item.describe());
}

// Equivalent with `where` clause (cleaner for multiple bounds)
fn log_item2<T>(item: &T)
where
    T: Describable + Clone + std::fmt::Debug,
{
    println!("[LOG] {:?} â€” {}", item, item.describe());
}
```

### `impl Trait` syntax (simpler)

```rust
fn log_item3(item: &impl Describable) {  // same as the generic version above
    println!("[LOG] {}", item.describe());
}

fn make_server() -> impl Describable {    // return "some type that is Describable"
    Server::new("anon".into(), 8)
}
```

### Common Standard Library Traits You'll Use Constantly

| Trait | What it does | C++/Java analogy |
|-------|-------------|-----------------|
| `Clone` | Explicit deep copy (`.clone()`) | Copy constructor |
| `Copy` | Implicit bitwise copy | POD types |
| `Debug` | Format with `{:?}` for debugging | `toString()` for debug |
| `Display` | Format with `{}` for user-facing output | `toString()` |
| `PartialEq`, `Eq` | `==` / `!=` | `operator==` / `equals()` |
| `PartialOrd`, `Ord` | `<`, `>`, sorting | `operator<` / `Comparable` |
| `Hash` | Hashing for `HashMap` keys | `hashCode()` |
| `Default` | Default value (`T::default()`) | Default constructor |
| `From` / `Into` | Type conversion | Conversion constructors |
| `Iterator` | Iteration protocol | `Iterator<T>` |
| `Drop` | Destructor | Destructor / `finalize()` |

Most of these can be auto-derived:

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct NodeId {
    rack: u32,
    slot: u32,
}
```

---

## 8. Error Handling: `Result` and `Option`

No exceptions in Rust. Errors are values.

### `Option<T>` â€” value might be absent

```rust
// Option is just: enum Option<T> { Some(T), None }

fn find_server(id: u32) -> Option<Server> {
    if id == 1 {
        Some(Server::new("node-01".into(), 64))
    } else {
        None
    }
}

// Handling:
match find_server(1) {
    Some(srv) => println!("{}", srv.summary()),
    None => println!("not found"),
}

// Or more concisely:
let srv = find_server(1).unwrap();             // panics if None (like .get() on null)
let srv = find_server(1).unwrap_or(default);   // fallback
let srv = find_server(1).expect("server 1 must exist"); // panic with message
```

### `Result<T, E>` â€” operation might fail

```rust
// Result is just: enum Result<T, E> { Ok(T), Err(E) }

use std::fs;
use std::io;

fn read_config(path: &str) -> Result<String, io::Error> {
    fs::read_to_string(path)
}

fn main() {
    match read_config("/etc/myapp.conf") {
        Ok(contents) => println!("Config: {contents}"),
        Err(e) => eprintln!("Failed: {e}"),
    }
}
```

### The `?` Operator (This Is Huge)

`?` propagates errors upward. If the Result is `Err`, return early with that error. If `Ok`, unwrap the value. This replaces try-catch with zero boilerplate.

```rust
fn load_and_parse_config(path: &str) -> Result<Config, Box<dyn std::error::Error>> {
    let contents = fs::read_to_string(path)?;   // returns Err early if file read fails
    let config: Config = serde_json::from_str(&contents)?;  // returns Err if parse fails
    Ok(config)
}
```

**C++ analogy**: Like if every function returned `std::expected<T, E>` and you had a concise syntax for early returns.

**Practical advice**: Use `anyhow::Result` (from the `anyhow` crate) for applications and `thiserror` for libraries.

```rust
// In Cargo.toml: anyhow = "1"
use anyhow::{Context, Result};

fn load_config(path: &str) -> Result<Config> {
    let contents = fs::read_to_string(path)
        .context("failed to read config file")?;    // adds context to error
    let config = serde_json::from_str(&contents)
        .context("failed to parse config")?;
    Ok(config)
}
```

---

## 9. Collections & Iterators

### Key Collections

```rust
use std::collections::HashMap;

// Vec<T> â€” dynamic array (like std::vector / ArrayList)
let mut nums: Vec<i32> = vec![1, 2, 3];
nums.push(4);

// String â€” owned, growable UTF-8 string
let mut s = String::from("hello");
s.push_str(" world");

// &str â€” string slice (borrowed view into a String or literal)
let slice: &str = &s[0..5];

// HashMap<K, V> â€” hash map (like std::unordered_map / HashMap)
let mut scores: HashMap<String, i32> = HashMap::new();
scores.insert("node-01".into(), 95);

// VecDeque, BTreeMap, BTreeSet, HashSet also available
```

### Iterators (Rust's Secret Weapon)

Rust iterators are lazy, zero-cost abstractions. They compile down to the same code as hand-written loops.

```rust
let nums = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Chained iterator operations
let result: Vec<i32> = nums.iter()
    .filter(|&&x| x % 2 == 0)       // keep evens
    .map(|&x| x * x)                // square them
    .collect();                       // collect into Vec
// result = [4, 16, 36, 64, 100]

// Sum
let total: i32 = nums.iter().sum();

// Find
let first_big = nums.iter().find(|&&x| x > 5);  // Option<&i32>

// for loop (uses IntoIterator under the hood)
for num in &nums {
    println!("{num}");
}

// Enumerate (like Python)
for (i, num) in nums.iter().enumerate() {
    println!("[{i}] = {num}");
}

// Iterating over HashMap
for (key, value) in &scores {
    println!("{key}: {value}");
}
```

**Key iterator methods**: `map`, `filter`, `flat_map`, `fold`, `reduce`, `take`, `skip`, `zip`, `enumerate`, `any`, `all`, `find`, `position`, `collect`, `count`, `sum`, `min`, `max`, `chain`, `peekable`.

`.collect()` can produce different collection types based on the type annotation â€” it's generic over the output type.

---

## 10. Closures

```rust
// Type-inferred closure
let add = |a, b| a + b;
println!("{}", add(2, 3));

// With explicit types
let square = |x: i32| -> i32 { x * x };

// Closures capture variables from their environment
let threshold = 50;
let above_threshold = |x: &i32| *x > threshold;    // borrows `threshold`

let results: Vec<&i32> = nums.iter().filter(|x| above_threshold(x)).collect();

// Move closure â€” takes ownership of captured variables
let name = String::from("venkat");
let greeting = move || println!("Hello, {name}");    // `name` moved into closure
// `name` is no longer usable here
greeting();
```

Closures implement one or more of: `Fn` (borrows immutably), `FnMut` (borrows mutably), `FnOnce` (takes ownership). The compiler figures this out.

---

## 11. Smart Pointers

| Type | What it does | C++ analogy |
|------|-------------|-------------|
| `Box<T>` | Heap allocation, single owner | `std::unique_ptr<T>` |
| `Rc<T>` | Reference-counted, single thread | `std::shared_ptr<T>` |
| `Arc<T>` | Reference-counted, thread-safe | `std::shared_ptr<T>` (atomic) |
| `RefCell<T>` | Interior mutability (runtime borrow checks) | â€” |
| `Mutex<T>` | Mutual exclusion with owned data | `std::mutex` + the data it protects |
| `RwLock<T>` | Reader-writer lock with owned data | `std::shared_mutex` + data |

```rust
// Box: heap allocation
let boxed: Box<i32> = Box::new(42);

// Arc + Mutex: shared mutable state across threads
use std::sync::{Arc, Mutex};

let counter = Arc::new(Mutex::new(0));
let counter_clone = Arc::clone(&counter);

std::thread::spawn(move || {
    let mut num = counter_clone.lock().unwrap();
    *num += 1;
});
```

**Key insight**: In Rust, `Mutex<T>` owns the data it protects. You can't access the data without locking. This makes data races structurally impossible.

---

## 12. Concurrency

### Threads

```rust
use std::thread;

let handle = thread::spawn(|| {
    println!("hello from thread");
    42   // return value
});

let result = handle.join().unwrap();  // wait + get result
```

### Channels (message passing)

```rust
use std::sync::mpsc;  // multi-producer, single-consumer

let (tx, rx) = mpsc::channel();
let tx2 = tx.clone();   // clone sender for multiple producers

thread::spawn(move || { tx.send("from thread 1").unwrap(); });
thread::spawn(move || { tx2.send("from thread 2").unwrap(); });

for msg in rx {  // blocks until all senders dropped
    println!("Got: {msg}");
}
```

### Async/Await (brief overview)

Rust has async syntax but no built-in runtime. You pick one (usually `tokio`).

```rust
// Cargo.toml: tokio = { version = "1", features = ["full"] }

#[tokio::main]
async fn main() {
    let result = fetch_data().await;
    println!("{result}");
}

async fn fetch_data() -> String {
    // async operations here
    "data".to_string()
}
```

---

## 13. Modules & Visibility

```rust
// In src/main.rs or src/lib.rs

mod network {                    // inline module
    pub struct Connection {      // pub = public
        pub host: String,
        port: u16,               // private by default
    }

    impl Connection {
        pub fn new(host: String, port: u16) -> Self {
            Connection { host, port }
        }

        pub fn connect(&self) {
            println!("Connecting to {}:{}", self.host, self.port);
        }
    }

    pub mod dns {                // nested module
        pub fn resolve(hostname: &str) -> String {
            format!("192.168.1.1 (resolved {hostname})")
        }
    }
}

fn main() {
    let conn = network::Connection::new("10.0.0.1".into(), 8080);
    conn.connect();
    let ip = network::dns::resolve("node-01");
}
```

For file-based modules:
```
src/
â”œâ”€â”€ main.rs         // declares: mod network;
â”œâ”€â”€ network/
â”‚   â”œâ”€â”€ mod.rs      // declares: pub mod dns;
â”‚   â””â”€â”€ dns.rs      // the dns module
```

Or the newer flat style (Rust 2018+):
```
src/
â”œâ”€â”€ main.rs         // declares: mod network;
â”œâ”€â”€ network.rs      // the network module, declares: pub mod dns;
â”œâ”€â”€ network/
â”‚   â””â”€â”€ dns.rs
```

`use` brings items into scope:
```rust
use network::Connection;
use std::collections::HashMap;
use std::io::{self, Read, Write};  // multiple imports
```

---

## 14. Generics

Like C++ templates / Java generics, but with trait bounds instead of SFINAE / concepts.

```rust
// Generic function
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in &list[1..] {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// Generic struct
struct Cache<K, V> {
    entries: HashMap<K, V>,
    max_size: usize,
}

impl<K: Eq + Hash, V> Cache<K, V> {
    fn new(max_size: usize) -> Self {
        Cache {
            entries: HashMap::new(),
            max_size,
        }
    }

    fn get(&self, key: &K) -> Option<&V> {
        self.entries.get(key)
    }
}
```

### Dynamic Dispatch (`dyn Trait`)

When you need runtime polymorphism (like virtual functions in C++ / interface references in Java):

```rust
fn log_all(items: &[&dyn Describable]) {
    for item in items {
        println!("{}", item.describe());
    }
}

// Or with Box for owned trait objects
fn get_backend(config: &str) -> Box<dyn StorageTrait> {
    match config {
        "ceph" => Box::new(CephBackend::new()),
        "local" => Box::new(LocalBackend::new()),
        _ => panic!("unknown backend"),
    }
}
```

`dyn Trait` = vtable dispatch (like C++ virtual). `impl Trait` / generics = monomorphization (like C++ templates). Prefer generics for performance; use `dyn` when you need heterogeneous collections or runtime selection.

---

## 15. String Types Cheat Sheet

This trips up every newcomer:

| Type | What | Analogy |
|------|------|---------|
| `String` | Owned, heap-allocated, growable | `std::string` |
| `&str` | Borrowed slice (view into a String or literal) | `std::string_view` / `const char*` |

```rust
let owned: String = String::from("hello");   // or "hello".to_string()
let slice: &str = &owned;                     // borrow as slice
let literal: &str = "hello";                  // string literal (lives in binary, static lifetime)

// Convert between them:
let s: String = "hello".to_string();          // &str â†’ String
let s: String = String::from("hello");        // same
let s: &str = &owned;                         // String â†’ &str (via Deref coercion)
let s: &str = owned.as_str();                 // explicit
```

**Rule of thumb**: Functions should take `&str` as input (accepts both) and return `String` if they're creating new string data.

---

## 16. Testing

Tests live right next to the code. No separate test files needed (though you can have them).

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]                       // only compiled during `cargo test`
mod tests {
    use super::*;                  // import from parent module

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }

    #[test]
    #[should_panic(expected = "overflow")]
    fn test_overflow() {
        // test that something panics
    }
}
```

Integration tests go in `tests/` directory at the project root.

---

## 17. Practical Patterns You'll Use Daily

### Builder Pattern (common in Rust APIs)

```rust
let client = ClientBuilder::new()
    .timeout(Duration::from_secs(30))
    .max_retries(3)
    .base_url("https://api.example.com")
    .build()?;
```

### `From` / `Into` Conversions

```rust
impl From<NodeConfig> for Server {
    fn from(config: NodeConfig) -> Self {
        Server::new(config.hostname, config.cores)
    }
}

// Now you can do:
let server: Server = config.into();
let server = Server::from(config);
```

### Type Aliases

```rust
type Result<T> = std::result::Result<T, MyError>;   // common in libraries
type NodeMap = HashMap<String, Vec<Server>>;
```

### Destructuring

```rust
let (x, y, z) = (1, 2, 3);

let Server { hostname, cpu_cores, .. } = &server;   // struct destructuring

if let Ok(config) = load_config("path") {
    // use config
}
```

---

## 18. Key Differences Cheat Sheet

| Concept | C++ | Java | Rust |
|---------|-----|------|------|
| Memory | Manual / RAII | GC | Ownership + RAII |
| Null | `nullptr` | `null` | `Option<T>` (no null) |
| Errors | Exceptions / error codes | Exceptions | `Result<T, E>` |
| Inheritance | Class hierarchy | Class hierarchy | **None** (use traits + composition) |
| Polymorphism | Virtual functions | Interfaces | Traits (`dyn` or generics) |
| Concurrency safety | "be careful" | "be careful" | Compile-time enforcement |
| Package manager | ??? | Maven/Gradle | Cargo (it's great) |
| Strings | `std::string` / `const char*` | `String` | `String` / `&str` |
| Default mutability | Mutable | Mutable (refs) | **Immutable** |

---

## 19. Quick Syntax Reference

```rust
// Variables
let x = 5;                     // immutable
let mut y = 10;                // mutable
let z: i64 = 100;             // explicit type

// Functions
fn add(a: i32, b: i32) -> i32 {
    a + b                       // no semicolon = return value (expression)
}

// Conditionals (expressions â€” they return values)
let status = if cpu_load > 90 { "critical" } else { "ok" };

// Loops
for item in &collection { }
for i in 0..10 { }            // 0 to 9
for i in 0..=10 { }           // 0 to 10 (inclusive)
while condition { }
loop { break value; }          // infinite loop, can return a value

// Printing
println!("Hello {name}");                      // string interpolation
println!("Debug: {:?}", some_struct);           // debug format
println!("Pretty debug: {:#?}", some_struct);   // pretty-printed debug
eprintln!("Error: {e}");                        // print to stderr

// Turbofish (explicit type for generic functions)
let nums = "1,2,3".split(',').collect::<Vec<&str>>();
```

---

## 20. Serde: Serialization & Deserialization

Serde is Rust's de facto serialization framework. It's fast, flexible, and works with JSON, TOML, YAML, MessagePack, and dozens of other formats.

### Basic Setup

```toml
# Cargo.toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"    # for JSON
toml = "0.8"          # for TOML
```

### Derive Macros: The 90% Case

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct ServerConfig {
    hostname: String,
    port: u16,
    #[serde(default)]                    // use Default::default() if missing
    enabled: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<String>,
    #[serde(rename = "maxConnections")]  // different name in JSON
    max_connections: u32,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Deserialize from JSON
    let json = r#"{
        "hostname": "node-01",
        "port": 8080,
        "maxConnections": 1000
    }"#;

    let config: ServerConfig = serde_json::from_str(json)?;
    println!("{:?}", config);

    // Serialize to JSON
    let output = serde_json::to_string_pretty(&config)?;
    println!("{output}");

    Ok(())
}
```

### Common Serde Attributes

| Attribute | Effect |
|-----------|--------|
| `#[serde(rename = "name")]` | Use different field name in serialized form |
| `#[serde(rename_all = "camelCase")]` | Rename all fields (struct-level) |
| `#[serde(default)]` | Use `Default::default()` if field missing |
| `#[serde(skip)]` | Don't serialize or deserialize this field |
| `#[serde(skip_serializing)]` | Only deserialize, not serialize |
| `#[serde(skip_serializing_if = "Option::is_none")]` | Conditionally skip |
| `#[serde(flatten)]` | Flatten nested struct into parent |
| `#[serde(with = "module")]` | Use custom serialize/deserialize functions |
| `#[serde(untagged)]` | For enums: no tag, tries each variant |

### Enums in Serde

```rust
#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]              // "internally tagged"
enum StorageBackend {
    #[serde(rename = "local")]
    Local { path: String },
    #[serde(rename = "s3")]
    S3 { bucket: String, region: String },
}

// Serializes to: {"type": "local", "path": "/data"}
// vs default (externally tagged): {"Local": {"path": "/data"}}
```

Enum representations:

- **Externally tagged** (default): `{"Variant": {...}}`
- **Internally tagged** (`#[serde(tag = "type")]`): `{"type": "Variant", ...}`
- **Adjacently tagged** (`#[serde(tag = "t", content = "c")]`): `{"t": "Variant", "c": {...}}`
- **Untagged** (`#[serde(untagged)]`): tries each variant, no tag

### Custom Serialization

```rust
use serde::{Serializer, Deserializer};

#[derive(Debug)]
struct Timestamp(i64);

impl Serialize for Timestamp {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // Serialize as ISO 8601 string instead of raw i64
        let datetime = chrono::DateTime::from_timestamp(self.0, 0).unwrap();
        serializer.serialize_str(&datetime.to_rfc3339())
    }
}
```

### Reading Config Files

```rust
use std::fs;

// TOML config file
fn load_toml_config(path: &str) -> Result<ServerConfig, Box<dyn std::error::Error>> {
    let contents = fs::read_to_string(path)?;
    let config: ServerConfig = toml::from_str(&contents)?;
    Ok(config)
}

// JSON config file
fn load_json_config(path: &str) -> Result<ServerConfig, Box<dyn std::error::Error>> {
    let contents = fs::read_to_string(path)?;
    let config: ServerConfig = serde_json::from_str(&contents)?;
    Ok(config)
}
```

**Practical tip**: Use `serde_json::Value` for dynamic/unknown JSON structures:

```rust
use serde_json::Value;

let v: Value = serde_json::from_str(json)?;
let hostname = v["hostname"].as_str().unwrap_or("unknown");
```

---

## 21. Macros

Macros are code that writes code. Rust has two types: declarative macros (`macro_rules!`) and procedural macros.

### Declarative Macros (`macro_rules!`)

These are pattern-matching based. You've already used them: `println!`, `vec!`, `format!`.

```rust
// Simple macro
macro_rules! say_hello {
    () => {
        println!("Hello!");
    };
}

// With arguments
macro_rules! create_function {
    ($name:ident) => {
        fn $name() {
            println!("Function {:?} was called", stringify!($name));
        }
    };
}

create_function!(foo);  // creates: fn foo() { ... }
create_function!(bar);  // creates: fn bar() { ... }

fn main() {
    say_hello!();
    foo();
    bar();
}
```

### Fragment Types (What You Can Match)

| Fragment | Matches | Example |
|----------|---------|---------|
| `$x:ident` | Identifier | `foo`, `my_var` |
| `$x:expr` | Expression | `1 + 2`, `foo()` |
| `$x:ty` | Type | `i32`, `Vec<String>` |
| `$x:path` | Path | `std::collections::HashMap` |
| `$x:stmt` | Statement | `let x = 1;` |
| `$x:block` | Block | `{ ... }` |
| `$x:item` | Item (fn, struct, etc.) | `fn foo() {}` |
| `$x:pat` | Pattern | `Some(x)`, `_` |
| `$x:literal` | Literal | `42`, `"hello"` |
| `$x:tt` | Token tree (anything) | any single token or `(...)`, `[...]`, `{...}` |

### Repetition

```rust
// The vec! macro (simplified)
macro_rules! my_vec {
    // Match zero or more expressions separated by commas
    ( $( $elem:expr ),* ) => {
        {
            let mut v = Vec::new();
            $( v.push($elem); )*    // repeat the push for each element
            v
        }
    };
}

let nums = my_vec![1, 2, 3, 4, 5];
```

Repetition operators:
- `*` â€” zero or more
- `+` â€” one or more
- `?` â€” zero or one

### Practical Example: A Logging Macro

```rust
macro_rules! log_debug {
    ($($arg:tt)*) => {
        #[cfg(debug_assertions)]
        {
            eprintln!("[DEBUG {}:{}] {}", file!(), line!(), format!($($arg)*));
        }
    };
}

fn process_data(x: i32) {
    log_debug!("Processing value: {}", x);
    // In release builds, this compiles to nothing
}
```

### Procedural Macros (Brief Overview)

Proc macros are more powerful but require a separate crate. There are three types:

1. **Derive macros** â€” `#[derive(MyTrait)]`
2. **Attribute macros** â€” `#[my_attribute]`
3. **Function-like macros** â€” `my_macro!(...)`

```rust
// Using a derive macro (you use these all the time)
#[derive(Debug, Clone, Serialize, Deserialize)]
struct MyStruct { ... }

// Using an attribute macro
#[tokio::main]           // transforms fn main into async runtime setup
async fn main() { ... }

#[test]                  // marks function as a test
fn test_something() { ... }
```

Writing proc macros requires the `proc_macro`, `syn` (parsing), and `quote` (code generation) crates:

```rust
// In a separate crate with proc-macro = true in Cargo.toml
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyDebug)]
pub fn my_debug_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;

    let expanded = quote! {
        impl std::fmt::Debug for #name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, stringify!(#name))
            }
        }
    };

    TokenStream::from(expanded)
}
```

### When to Use Macros

**Use declarative macros** (`macro_rules!`) for:
- Reducing repetitive code patterns
- DSLs (domain-specific languages)
- Compile-time code generation
- Variadic functions (Rust doesn't have them otherwise)

**Use derive macros** when:
- You need to implement traits automatically
- The implementation follows a pattern based on struct/enum structure

**Prefer functions over macros** when:
- A regular function would work (macros are harder to debug)
- You don't need compile-time code generation

---

## 22. Unsafe Rust

`unsafe` lets you do five things the compiler can't verify. It doesn't turn off the borrow checker â€” it just gives you access to low-level operations.

### What Unsafe Allows

1. Dereference raw pointers
2. Call unsafe functions/methods
3. Access/modify mutable static variables
4. Implement unsafe traits
5. Access fields of `union`s

### Raw Pointers

```rust
fn main() {
    let mut x = 10;

    // Creating raw pointers is safe
    let ptr_immut: *const i32 = &x;       // immutable raw pointer
    let ptr_mut: *mut i32 = &mut x;       // mutable raw pointer

    // Dereferencing requires unsafe
    unsafe {
        println!("Value: {}", *ptr_immut);
        *ptr_mut = 20;
        println!("New value: {}", *ptr_mut);
    }
}
```

Raw pointers:
- Are allowed to be null
- Don't guarantee they point to valid memory
- Can have multiple mutable pointers to the same location
- Don't have lifetimes (no borrow checker enforcement)

### Unsafe Functions

```rust
// Marked unsafe because caller must ensure preconditions
unsafe fn dangerous(ptr: *const i32) -> i32 {
    *ptr    // could crash if ptr is null or invalid
}

fn main() {
    let x = 42;
    let result = unsafe { dangerous(&x) };
    println!("{result}");
}
```

### Safe Abstractions Over Unsafe Code

This is the key pattern: wrap unsafe code in safe interfaces.

```rust
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();
    let ptr = values.as_mut_ptr();

    assert!(mid <= len);  // safety check

    unsafe {
        (
            std::slice::from_raw_parts_mut(ptr, mid),
            std::slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}

// The function itself is safe because:
// 1. We validated mid <= len
// 2. The two slices don't overlap
// 3. The lifetimes are correctly tied to the input
```

### Calling C Functions (FFI)

```rust
// Link to the C standard library
extern "C" {
    fn abs(input: i32) -> i32;
    fn strlen(s: *const i8) -> usize;
}

fn main() {
    unsafe {
        println!("abs(-5) = {}", abs(-5));
    }
}
```

For proper FFI, use the `libc` crate and consider `bindgen` for generating bindings automatically.

### Mutable Static Variables

```rust
static mut COUNTER: u32 = 0;

fn increment() {
    unsafe {
        COUNTER += 1;
    }
}

fn main() {
    increment();
    increment();
    unsafe {
        println!("COUNTER: {COUNTER}");
    }
}
```

**Avoid mutable statics** â€” they're a source of data races. Use `AtomicU32`, `Mutex`, or `lazy_static!` / `once_cell` instead.

### When to Use Unsafe

**Legitimate uses:**
- FFI (calling C libraries)
- Performance-critical code where you can prove safety but the compiler can't
- Implementing low-level data structures (linked lists, trees with parent pointers)
- Interfacing with hardware / OS APIs

**Guidelines:**
1. Keep `unsafe` blocks as small as possible
2. Document the invariants you're maintaining
3. Wrap unsafe code in safe abstractions
4. Use `#[deny(unsafe_code)]` crate-wide, then allow it explicitly where needed

```rust
// Good: minimal unsafe, safe wrapper
pub fn get_unchecked(slice: &[i32], index: usize) -> i32 {
    // SAFETY: Caller must ensure index < slice.len()
    unsafe { *slice.get_unchecked(index) }
}

// Better: don't expose unsafe at all
pub fn get_or_default(slice: &[i32], index: usize, default: i32) -> i32 {
    slice.get(index).copied().unwrap_or(default)
}
```

### Common Unsafe Patterns to Know

```rust
// Transmute: reinterpret bytes (very dangerous)
let x: i32 = unsafe { std::mem::transmute([0u8, 0, 0, 1]) };

// ManuallyDrop: prevent destructor from running
let mut s = std::mem::ManuallyDrop::new(String::from("hello"));
// s will NOT be dropped when it goes out of scope

// MaybeUninit: uninitialized memory
use std::mem::MaybeUninit;
let mut x = MaybeUninit::<i32>::uninit();
unsafe {
    x.as_mut_ptr().write(42);
    let val = x.assume_init();  // now safe to use
}
```

**Bottom line**: Most Rust code is 100% safe. You can write entire applications without a single `unsafe`. But when you need it â€” for FFI, hardware access, or performance â€” it's there, and the explicit marking makes it easy to audit.

---

## 23. What to Learn Next

Once you're comfortable with the above, these are the next frontiers:

- **Async Rust in depth**: Tokio runtime, futures, `select!`, streams, async traits
- **Error handling patterns**: `thiserror` for libraries, `anyhow` for applications
- **Pinning**: Required for self-referential types in async code
- **Advanced FFI**: `bindgen` for auto-generating C bindings, `cbindgen` for exposing Rust to C
- **Embedded Rust**: `no_std`, bare metal programming
- **SIMD and performance**: `std::simd`, profiling with `perf`, `criterion` for benchmarks
- **The `std` docs**: Genuinely excellent â€” <https://doc.rust-lang.org/std/>

> **Best way to learn**: Pick a small project (a CLI tool, a simple HTTP server with axum/actix, a file processor) and just build. The compiler errors are famously helpful â€” read them carefully, they usually tell you exactly what to do.
